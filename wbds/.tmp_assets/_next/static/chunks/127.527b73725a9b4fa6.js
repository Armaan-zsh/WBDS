"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[127],{3127:function(n,e,o){o.r(e),o.d(e,{default:function(){return a}});var i=o(2347),r=o(8945),t=o(6581);function a(){let n=(0,r.useRef)(),e=(0,r.useRef)(),o=(0,r.useRef)(),a=(0,r.useRef)({uTime:{value:0}}).current,l=(0,r.useRef)({uTime:{value:0}}).current;return(0,t.F)(o=>{let i=o.clock.getElapsedTime();n.current&&(n.current.material.uniforms.uTime.value=i),e.current&&(e.current.material.uniforms.uTime.value=i)}),(0,i.jsxs)("group",{children:[(0,i.jsx)("color",{attach:"background",args:["#05000a"]}),(0,i.jsx)("fog",{attach:"fog",args:["#05000a",15,60]}),(0,i.jsxs)("mesh",{ref:n,position:[0,8,-45],children:[(0,i.jsx)("planeGeometry",{args:[22,22]}),(0,i.jsx)("shaderMaterial",{vertexShader:"\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:'\nvarying vec2 vUv;\nuniform float uTime;\n\nvoid main() {\n  vec2 center = vec2(0.5, 0.5);\n  float dist = distance(vUv, center);\n  \n  // Basic Circle\n  float alpha = smoothstep(0.5, 0.48, dist);\n  \n  // Gradient (Deep Red -> Orange -> Yellow)\n  vec3 colorBottom = vec3(0.6, 0.0, 0.2); // Deep Red/Purple bottom\n  vec3 colorMid = vec3(1.0, 0.3, 0.0);    // Orange\n  vec3 colorTop = vec3(1.0, 0.9, 0.1);    // Bright Yellow\n  \n  vec3 color = mix(colorBottom, colorMid, vUv.y * 2.0);\n  if (vUv.y > 0.5) {\n      color = mix(colorMid, colorTop, (vUv.y - 0.5) * 2.0);\n  }\n  \n  // Scanlines (The "Blind" effect)\n  float scanline = sin(vUv.y * 60.0 - uTime * 0.2); \n  // Cutout scanlines\n  if (vUv.y < 0.6) {\n      float cut = smoothstep(0.2, 0.0, scanline);\n      alpha *= cut;\n  }\n\n  // Glow\n  float glow = 1.0 - smoothstep(0.0, 0.5, dist);\n  color += vec3(1.0, 0.4, 0.0) * glow * 0.6; // Orange glow\n\n  gl_FragColor = vec4(color, alpha);\n}\n',uniforms:a,transparent:!0})]}),(0,i.jsxs)("mesh",{ref:o,position:[0,0,-42],children:[(0,i.jsx)("planeGeometry",{args:[60,12]}),(0,i.jsx)("shaderMaterial",{vertexShader:"\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"\nvarying vec2 vUv;\nuniform float uTime;\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvoid main() {\n  vec2 uv = vUv;\n  float buildings = 0.0;\n  float windows = 0.0;\n  \n  // --- Layer 1: Back/Tall Buildings ---\n  float density1 = 40.0;\n  float id1 = floor(uv.x * density1);\n  float h1 = random(vec2(id1, 1.0)) * 0.5 + 0.2; // Taller (0.2 to 0.7)\n  \n  if (uv.y < h1) {\n      buildings = 1.0;\n      \n      // Windows logic Layer 1\n      vec2 winUv = uv * vec2(density1, 40.0); // 40 floors\n      float winGrid = step(0.4, fract(winUv.x)) * step(0.4, fract(winUv.y)); // Grid pattern\n      float winRand = step(0.7, random(floor(winUv) + vec2(id1, 0.0))); // Random lights\n      windows += winGrid * winRand * 0.5; // Dimmer windows in back\n  }\n  \n  // --- Layer 2: Front/Short/Dense Buildings ---\n  float density2 = 70.0;\n  float id2 = floor(uv.x * density2 + 123.0); // Offset x\n  float h2 = random(vec2(id2, 2.0)) * 0.25 + 0.05; // Shorter\n  \n  if (uv.y < h2) {\n      buildings = 1.0;\n      \n      // Windows logic Layer 2\n      vec2 winUv = uv * vec2(density2, 60.0);\n      float winGrid = step(0.4, fract(winUv.x)) * step(0.4, fract(winUv.y));\n      float winRand = step(0.6, random(floor(winUv) + vec2(id2, 10.0)));\n      windows = winGrid * winRand; // Override back windows\n  }\n  \n  // Base Building Color (Black Silhouette)\n  vec3 color = vec3(0.0, 0.0, 0.05);\n  \n  // Window Light Color (Cyan/White mix)\n  vec3 winColor = mix(vec3(0.1, 0.8, 1.0), vec3(1.0), 0.5);\n  \n  color += winColor * windows; // Add lights\n  \n  // Alpha: 1 where buildings are\n  gl_FragColor = vec4(color, buildings);\n}\n",uniforms:{uTime:{value:0}},transparent:!0})]}),(0,i.jsxs)("mesh",{ref:e,position:[0,-4,-20],rotation:[-Math.PI/2,0,0],children:[(0,i.jsx)("planeGeometry",{args:[100,100]}),(0,i.jsx)("shaderMaterial",{vertexShader:"\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"\nvarying vec2 vUv;\nuniform float uTime;\n\nvoid main() {\n  vec2 uv = vUv;\n  // Cruising speed (reduced from 0.5)\n  uv.y += uTime * 0.15; \n  \n  // Grid Lines\n  float gridX = step(0.98, fract(uv.x * 20.0));\n  float gridY = step(0.98, fract(uv.y * 20.0));\n  float grid = max(gridX, gridY);\n  \n  float fade = 1.0 - smoothstep(0.0, 1.0, vUv.y); \n  \n  vec3 neonColor = vec3(0.8, 0.0, 1.0); \n  vec3 color = neonColor * grid * fade * 1.5; \n  vec3 baseColor = vec3(0.02, 0.0, 0.05);\n  \n  gl_FragColor = vec4(baseColor + color, 1.0);\n}\n",uniforms:l,transparent:!0})]}),(0,i.jsx)("ambientLight",{intensity:.2})]})}}}]);